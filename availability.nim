import posix/codes
import platforms

echo """
# GENERATED by gen_compat.nim
## USAGE
##   ```
##   when {XSI} <= posixCodes:
##     type A = object
##       when {RS} <= posixCodes:
##         a: int
##   ```

import codes

const posixCodes* = """

echo """
  ## Contains POSIX feature codes that this platform supports.
"""

for c in Code:
  echo c

# when platform.os == OS.linux:
#   import posix/linux_compat
# elif platform.os == OS.macos:
#   import posix/macos_compat
# elif platform.os == OS.freebsd:
#   import posix/freebsd_compat
# elif platform.os == OS.openbsd:
#   import posix/openbsd_compat

# import macros, strutils

# proc supportsAnyOfPosixFeatures(a: NimNode): bool =
#   for x in a:
#     if parseEnum[Code]($x) in posixCodes:
#       return true

# proc supportsPosixFeatures(a: NimNode): bool =
#   for c in a:
#     if parseEnum[Code]($c) notin posixCodes:
#       return false
#   return true

# template p*(codes, def) =
#   def

# macro posix*(codes, def) =
#   doAssert supportsPosixFeatures(codes), "one or more POSIX features are not available: " & codes.repr
#   def

# macro posixAny*(codes, def) =
#   doAssert supportsAnyOfPosixFeatures(codes), "one or more POSIX features are not available: " & codes.repr
#   def

# proc t() {.posixAny: {XSI, BE}.} =
#   echo "here"

# t()

# template posix(codes) {.pragma.}
# template posixAny(codes) {.pragma.}

# when {XSI} <= posixCodes:
#   type A = object
#     when {BE} <= posixCodes:
#       a: int
